---
layout: post
title: 红黑树(RB-Tree) - 思路与实现
date: 2018-8-28 10:48:30
category: 算法
draft: false
---

红黑树的数据结构已经被研究了多年，最为最广泛应用的数据结构之一，因为其具有优良的特性，即自平衡性，所以无论在最坏或者是最好的输出中，红黑树的高度都十分稳定（**红黑树可以能确保树的最长路径不大于两倍的最短路径的长度**）。

<!--more-->

但是相对的，红黑树的操作也较为复杂，本文将会从 **2-3 树出发**，介绍 2-3 树到红黑树的演化，最后介绍目前 STL 模型中的红黑树模型实现，详细介绍红黑树的发展历程（红黑树算法还在不断地完善中，本文只是简要地叙述模型）。

另外本文在未来还会补充 AA 树等其他的红黑树变种，但是更新看心情咯（当场去世）。AVL 树的内容我也会等未来慢慢添加进去的，不过 AVL 树没有红黑树应用广泛，而且实现方法其实和红黑树基本一样，所以就简单叙述了。

首先说明一下，树和哈希表的对比，哈希表的读取插入性能强于树，但是哈希表在面对持续输入未知数据的情况下，无法做到每个键值都是唯一的，而且哈希表需要更大的空间来存放，所以树在针对动态数据的情况下，还是十分重要的。而对于已知的静态数据来说，通过不同的算法实现哈希表还是更为高效的。

## 二叉树的缺点
为什么我们不使用二叉树作为各种容器的数据结构呢，因为二叉树的稳定性比较差。我们知道，二叉树的高度其实是没有保证的，也就是说，如果在遇到连续顺序输入的情况下，二叉树的高度会非常的高，这样查找的时间效率会近似于 O(N)，达不到使用的要求。

所以，人们在一开始就思考，我们可以通过一些小小的变换使得二叉树成为平衡的树嘛，于是就产生了 AVL 树。AVL 树和红黑树类似，也是一种自平衡二叉树，实现过程也与红黑树类似，但是由于 AVL 树对于平衡的要求比较严格，所以在自平衡的过程中，旋转的次数比较多，虽然 AVL 树和红黑树的算法复杂度一样，但是统计出的性能不如红黑树。

## 2-3 查找树
我们使得一个标准的二叉查找树同时具有二叉节点和三叉节点。

![][1]

2-3 查找树的查找行为，是与二叉树类似的，但是又有些不同，因为具有了三叉节点，所以查找的时候有可能遇到 3 节点或者 2 节点，需要根据情况判断：

![][2]

具体的 2-3 树的插入，删除，替换细节不做过多介绍，但是在看下面的内容之前，最好还是先了解一下 2-3 树的变换过程：
[2-3 Tree Operation](https://en.wikipedia.org/wiki/2%E2%80%933_tree#Operations)

很简单，容易理解，2 节点插入就变为 3 节点，3 节点插入就变成 4 节点，然后转变成为三个 2 节点，其中的父节点和上层节点结合。通过仔细观察，这两种变换过程都保证了一个细节，也就是不管怎么插入，2-3 树都是平衡的，红黑树正是利用了这种性质，我们接下来会介绍红黑树的结构。

## 红黑树定义
既然大家都有一样的性质，为什么不用 2-3 树而偏要用红黑树呢？通过之前的描述我们就能看出来，2-3 树具有两种节点，我们需要维护两种同类型的节点，再插入时需要在两种节点间进行类型转换，实现这些过程需要大量的代码，而且效率也不高。我们希望利用更少的代码和开销来实现这种功能，这就是红黑树。

红黑树的基本思想是只利用标准的二叉查找树，和一些额外的信息（颜色）来表示 2-3 树。树中的链接被分为两类，一类是红链接，另外一类是黑链接。被红链接链接的两个节点相当于是一个三节点。红链接满足以下条件：

1. 红链接均为左链接
2. 没有任何一个节点同时和两条红链接相连
3. 树是完美平衡的，任意 NULL 链接通往根节点的路径上，黑链接的数量为定值。

## 红黑树的实现
这里红黑树的实现参考了 STL 函数库：

### RB-Tree Node
红黑树分为红黑两种颜色，在我们之前的描述中，被红色链接链接的子节点为红色节点，被黑色链接链接的节点为黑色节点。

```cpp
typedef bool __rb_tree_color_type;
const __rb_tree_color_type __rb_tree_red = false;
const __rb_tree_color_type __rb_tree_red = true;

struct __rb_tree_node_base
{
	typedef __rb_tree_color_type color_type;
	typedef __rb_tree_node_base* base_ptr;

	color_type color; // Color of the node, RED or BLACK
	base_ptr parent; // Child node can trace back to Root
	base_ptr left; // Left child ptr
	base_ptr right; // Right child ptr

	static base_ptr minimum(base_ptr x)
	{   // Find the smallest value 
		while (x->left != 0) x = x->left; 
		return x;
	}

	static base_ptr maximum(base_ptr x)
	{
		while (x->right != 0)x = x->right;
		return x;
	}
};

template <class Value>
struct __rb_tree_node : public __rb_tree_node_base 
{
	typedef __rb_tree_node<Value>* link_type;
	Value value_field;
};
```

[1]: /img/2018-8-28-RB-tree/2-3-1.png
[2]: /img/2018-8-28-RB-tree/2-3-2.png
