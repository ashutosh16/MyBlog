---
title: Deep understanding of C pointers
date: 2017-12-07
draft: false
---

 语言中，要说什么概念最难理解，那指针当仁不让处于第一的位置，初学者对于指针是叫苦不堪，即使是熟练地程序员在写程序的时候，复杂的指针也会使程序的可读性大大降低。

但是指针又是 C 语言的一个特点，使用指针可以使编程更加容易。而且有些任务，譬如动态内存分配，如 `malloc` `calloc` `realloc` 函数的使用又必须依赖指针，所以如果想要成为一个熟练的 C 程序员，理解熟练使用指针是非常必要的。

<!--more-->

## 什么是指针
首先，在程序运行中，变量都是存在计算机的内存中的。指针是一种变量，它的值是**另外一个变量的地址**，也就是直接的内存地址，在 32 位系统中，指针的大小为 4 字节（在远古时期的远指针，近指针，巨指针，等不参加讨论），很好理解，一个字节长度为 8 bits，4 bytes = 32 bits，如果在最新的 64 位系统中编译并且运行的话，指针会变成 8 字节的长度，因为对应的地址位宽增加了。

运行以下的内容就可以发现, 打印的是 8 个 16 进制的字符，也就是 4 个字节。

```c
#include <stdio.h>

int main () {

   int  var1;
   char var2[10];

   printf("Address of var1 variable: %x\n", &var1  );
   printf("Address of var2 variable: %x\n", &var2  );

   return 0;
}
```

运行结果：

```bash
$gcc -o main *.c
$main
Address of var1 variable: 9f98435c
Address of var2 variable: 9f984352
```

在上边的例子中，`var1` 就是一个指针，它内部存有一个 `int` 型变量的地址， 而 `var2` 存着一个 `char[10]` 数组的地址。在平常描述中，通常使用『**指向**』这个动词来描述指针与对应变量的关系，我们可以说 `var1` 指针指向某个（因为还未定义哪个） `int` 型的变量。通过这个例子的打印结果我们可以看到，不管指针指向什么类型的变量，它的本身长度，始终都是固定的值，在本例中为 4bytes，不同指针唯一的不同就是指针变量内部存的值的不同，也即是指针所对应的地址不同。

## 如何使用指针
**指针的操作符很少，只有 `&` `*` 两种。**

* `&` 是引用符号，对一个普通的变量，数组，结构，等类型使用可以取得其地址。
* `*` 是解除引用符号，对于指针使用可以返回其指向的值。

```c
#include <stdio.h>

int main () {
   int  var = 20;   /* 整形变量声明定义 */
   int  *ip;        /* 指针声明 */
   ip = &var;  /* 将 var 变量的值赋给 ip*/

   printf("var 的地址是: %x\n", &var  );
   printf("ip 中储存的地址是: %x\n", ip );
   printf("原本 *ip 的值是: %d\n", *ip );
   printf("原本 var 的值是: %d\n", var );

   *ip= 10;

   printf("*ip 现在的值是: %d\n", *ip );
   printf("var 现在的值是: %d\n", var );
   return 0;
}
```

运行结果:

```bash
$gcc -o main *.c
$main
var 的地址是: f977beb4
ip 中储存的地址是: f977beb4
原本 *ip 的值是: 20
原本 var 的值是: 20
*ip 现在的值是: 10
var 现在的值是: 10
```

可以看到，当我修改 `*ip` 的值的时候， `var` 整形变量的值也发生了变化，这是因为我们是通过 `ip` 这个指针修改的，程序通过这个指针中的地址找到了对应的内存（var 所在），然后将这段内存修改成为了 10 ，这个过程相当于直接修改了在内存中 `var` 对应的值。

**请不要直接将变量的值直接赋值给指针本身！**

错误用法：`ip = (int)10;`

```bash
warning: assignment makes pointer from integer without a cast [-Wint-conversion]
    ip=(int)10;
      ^
```

指针变量的类型和一般的变量不同，直接这样赋值会导致编译错误，而且这种操作毫无意义。

指针是可以赋给另外一个指针的，这样两个指针指向了同一个地方，但是这种一个地址对应两个指针的操作在某种意义上是比较危险的，因为这样对应的值很有可能被误修改，或者内存被释放后导致[迷途指针](https://zh.wikipedia.org/wiki/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88)。

## NULL 指针
又名**空指针**，指针内的值为 NULL，指针还没有分配指向的实体，NULL 指针会出现在指针的声明时，也就是我们第一个例子中的两个指针，只声明了对应的类型，没有实际赋予其地址，又称没有被初始化。

空指针中的值是 4 个字节的 0，而在计算机系统结构中，0 地址的内存一般情况下是被保留给操作系统运行的，里面已经有了一些操作系统运行中所需要的值，所以利用 NULL 指针修改对应的内存的话，后果可想而知。

解决空指针的办法就是在指针声明后，进行赋值，将指针变成一个指向固定地址的变量。

## 指针运算
指针的运算符有以下几种：

* `++`
* `--`
* `+`
* `-`

我们主要就 +/- 运算进行讲解，因为 ++/-- 不就是 +1/-1 么。

如果我们定义了一个指针指向一个 int 型变量（4 字节长度），请在脑中构思这个创建指针和定义的过程，然后我们对这个指针加 1。

实际上，指针内部的地址并不是简单的加 1，而是加了 4，也就是在内存中移动到了 4 个字节后的下一个 int 变量。

这个特性使得我们不用去注意一些非常底层的概念，最普遍的使用地点就是在一串同类数据中切换数据，也就是在数组中使用指针。

在使用这个的过程中，请保证自己不会将指针移动到未声明的内存空间中，譬如上述单个 int 变量的指针偏移，否则将有大几率损坏其他变量数据。

```c
#include <stdio.h>

const int MAX = 3;

int main () {

   int  var[] = {10, 100, 200};
   int  i, *ptr;
    
   ptr = var;

   for ( i = 0; i < MAX; i++) {

      printf("var[%d] 地址 = %x\n", i, ptr );
      printf("var[%d] 值 = %d\n", i, *ptr );

      ptr = ptr+1;      //等于 ptr++
   }
	
   return 0;
}
```

运行结果:

```bash
$gcc -o main *.c
$main
var[0] 地址 = 220fe454
var[0] 值 = 10
var[1] 地址 = 220fe458
var[1] 值 = 100
var[2] 地址 = 220fe45c
var[2] 值 = 200
```

可以看到地址每次增加的值是 4。在这个例子中，如果你仔细读代码则会发现，我们使用了如下的代码

```c
   ptr = var;
```

而在编译运行的过程中并没有错误产生，这是应为它本身就没有错误，在 c 语言中，数组的名字会被当做一个指针处理，其中的 var 可以被看做 `int * const var_name = &var[0];` 中的 `var_name`，也就是说，数组名其实是一个指针，而它对应的地址就是 var[0] 的地址。

由于这是一个常量指针，其特点是指针内的地址不可以变动，也就意味着这个指针不能够指向其他的 int 变量了。也就是:

```c
int * const var_name = &var[0];
var_name = (int *)10;
```

是错误的:

```bash
error: assignment of read-only variable ‘var_name’
    var_name = (int *)10;
             ^
```

我试了直接给 var = 另外的指针，但是显示错误不是这个，显示的是 `error: assignment to expression with array type` ，但是原理是一样的。

还有一种数组，叫做字符数组，其主要形式是以下形式：

```c
char ch[20]={"hello world"};
```

这句话，定义了一个具有 20 个元素的数组，元素的类型为 char 型，也就是字符型，数组的第一个元素是 h，第二个是 e，数组被依次填入"hello world\0"，其中 `\0` 为终止符。

在 C 语言中，"hello world" 这样的字符串其实本质是一个指针，指向字符串开头的地址。在赋值或者打印的时候，C 语言会使用这个指针自动的将字符串从头读取到终止符。

从下边这个例子来解释：

```c
#include <stdio.h>

const int MAX = 3;

int main () {

   char *ptr="Hello world";
   printf("%s",ptr);

   return 0;
}
```

运行结果是打印了 Hello world，在这个地方，我们直接用字符串给一个指针赋值了，但是编译器并没有报错。
  

## 二级指针
因为指针是一个变量，故其在内存中也有一个储存的地址，而这个地址可以赋值给另外一个指针。当一个指针指向另外一个指针的时候，此指针就是二级指针。

二级指针的声明如下:

```c
int **var;
```

如果你觉得之前的内容很简单，指针现在的恐怖之处才体现出来，对于二级指针的解除引用 `*` 一次之后还是指针，只有解除两次之后才能成为真正的指向的数值变量。

## 函数指针
在 C 语言中，函数指针一直就是一个很神奇的东西，因为它有很多违反常规的设定，函数其实和变量一样，都储存在内存中，只不过这部分内存存的是一些命令而不是值，函数名就像是数组名一样对应着它的入口地址，所以我们可以用一个指针指向函数，这样指针就能代表函数了。

函数指针和普通指针不同的是，函数指针声明的是函数的**返回值**和**参数**，而不是仅仅变量类型。

譬如：

```c
int (*p)(const char *);
```

声明了这个指针指向的是一个函数，该函数具有 int 返回值和 const char * （在 C 中遇到它，99% 对应字符串）的参数。

```c
#include <stdio.h>

int string_print(const char *s){
    printf("%s",s);
    return 0;
}

int main(){

    int a;
    int (*p)(const char *);
    
    p=&string_print;

    a=string_print("WINNER WINNER CHIKEN DINNER!\n");
    a=p("WINNER WINNER CHIKEN DINNER!\n");

    return 0;
}
```

运行结果：

```bash
$gcc -o main *.c
$main
WINNER WINNER CHIKEN DINNER!
WINNER WINNER CHIKEN DINNER!
```

看，这个指针指向函数后，用指针名就可以直接调用这个函数，如果有很多函数，我们就可以在运行的时候动态的调用不同的函数了。

如果你眼睛够尖，或者你认真看了我上面的所有内容的话，会发现一个问题，我这个地方给指针赋值用的是:

```c
    p=&string_print;
```

函数名不就是地址么？再取地址不就是二级指针了么？你想的不错，这个地方其实说明了一个问题，如果函数名是地址的话，我们调用就要用 `*` 来解除引用后才能声明和定义函数，但是 C 为了使大家使用方便就去掉了函数调用定义时加 `*` 的过程，也就是说使用函数名其实就已经是解除引用后的地址了，这样说可能看起来比较难受，其实，`p=&string_print;` 和 `p=string_print;` 这两句话在这里是完全一样的，哈哈，不信你试试，输出结果完全一样，编译也不会报错。也就是说函数名既可以看做是一个实际的实体，也可以看做是一个地址，但是在定义以及声明函数的时候，不能定义函数名前面加 `*`，因为这样就变成函数指针了。

```c
int (*string_print)(const char *s){
    printf("%s",s);
    return 0;
}
```

是错误的，无法通过编译，因为这样的 `string_print` 就是函数指针了哦。

## 指针结合
到此为止，一般的指针类型都已经介绍完毕了，但是这仅仅是指针的基础知识，有时候我们需要的是一些更加复杂的指针类型，譬如我想让 `p` 是一个指向数组的指针，在数组中的元素均为指向 `int` 的指针。那这个指针该怎么声明呢？

我们介绍了函数指针，在上个章节，有人会发现我在声明指针时，用小括号圈起来了指针（`int (*p)(const char *);`）,可能你会想为什么要多次一举的加上一个括号呢，这个地方就牵涉到了指针中运算符的优先级的问题。（这个括号是必须的，没有就不是函数指针了，而是返回指针的函数了）

在学习指针结合的开始，我们要首先了解 C 语言中的运算符的结合优先级，指针结合的优先级使用 C 语言中规定的运算符优先级。

参阅[C++ 运算符优先级](http://zh.cppreference.com/w/cpp/language/operator_precedence)。

大概浏览一下就可以咯，下面让我们先从简单的类型开始慢慢分析吧:

1. `int ptr;` 这是一个普通的整型变量。
2. `int *ptr;` 从 ptr 处开始，先与 \* 结合，说明 ptr 是一个指针，然后再与 int 结合，说明指针所指向的内容的类型为 int 型。所以 ptr 是一个返回整型数据的指针。
3. `int ptr[3];`  从 ptr 处开始，先与 \[] 结合，说明 ptr 是一个数组，然后与 int 结合，说明数组里面的元素类型是整型的，所以 ptr 是一个由整型数据组成的数组。
4. `int *ptr[3];` 从 ptr 开始，左边是 \* 运算，右边是 \[] 运算，由于 \[] 运算符的优先级比 \* 高，所以先与 [] 结合，说明 ptr 是一个数组，然后再与 \* 结合，说明数组元素的类型是指针类型，最后与 int 结合，说明指针所指向的内容的类型是整型数据。
所以 ptr 是一个**整型数据的指针**所组成的**数组**。
5. `int (*ptr)[3];` 从 ptr 开始，首先与 \* 结合，\() 是为了提高 \* 相对于 \[] 的优先级，所以 ptr 是一个指针，然后与 \[] 结合，说明 ptr 是指针，指向的内容是一个数组，最后与 int 结合，说明数组里的元素是整型的。
所以 ptr 是一个**指向由整型数据组成的数组**的**指针**。
6. `int **ptr;` 从 ptr 开始，先与 \* 结合，说是 ptr 是一个指针，然后再与 \* 结合，说明指针所指向的元素是指针，然后再与 int 结合，说明该指针所指向的元素是整型数据。
7. `int ptr(int);` 从 ptr 处起，先与 \() 结合，说明 ptr 是一个函数，然后进入 \() 里分析，说明该函数有一个整型变量的参数，然后再与外面的 int 结合，说明函数的返回值是一个整型数据。
8. `int (*ptr)(int);` 从 ptr 处开始，先与指针结合，说明 ptr 是一个指针，然后与 () 结合，说明指针指向的是一个函数，然后再与 () 里的 int 结合，说明函数有一个 int 型的参数，再与最外层的 int 结合,说明函数的返回类型是整型。
所以 ptr 是一个指向**有一个整型参数且返回类型为整型的函数**的指针。
9. `int *ptr(int);` 从 ptr 处开始，先与 () 结合，说明 ptr 是一个函数，然后与 \* 结合，说明函数返回值是一个指针，然后再与 int 结合，说明函数返回指针指向 int。
所以 ptr 是一个**有一个整型参数且返回类型为指向整型的指针**的**函数**。
10. `int *(*ptr(int))[3];` 难度 MAX，从 ptr 开始，先与 () 结合，说明 ptr 是一个函数,然后进入 () 里面，与 int 结合，说明函数有一个整型变量参数，然后再与外面的 \* 结合，说明函数返回的是一个指针（参考上边的第9条），然后到最外面一层，先与 [] 结合，说明返回的指针指向的是一个数组，然后再与 \* 结合，说明数组里的元素是指针，然后再与 int 结合，说明指针指向的内容是整型数据。
所以 ptr 是一个指向**参数为一个 int 且返回一个指向由整型指针变量组成的数组的指针变量**的**函数**。


上列中的 **4. 5.** 是很多考试的考点，其中 `int *ptr[3];` 中 ptr 有个称号叫做 **指针数组** ，`int (*ptr)[3];` 中 ptr 有个称号叫做 **数组指针**，连名字都几乎一模一样，新手大多头疼这两个的判断，其实按照上述的方法来处理指针结合的话，两种类型的区别还是很好判断的。

数组指针，是一个指向数组的指针，注意这里的指针不等同与数组名指针，这个指针指向的，是一个整体数组，而数组名指针指向的是数组中的元素。数组指针加 1 后，会跨过整个数组长度总和，而数组名加 1 只会增加一个元素的长度。举个例子就是：数组指针是班号，加 1 后移动到下个班，数组名是班级内的学号，加 1 后移动到下个学生。

![ap&pa.png][1]

其中 p 为普通函数名指针，ptr 为数组指针。
我们可以看到数组指针可以跳过一整个行数组，用途在哪里最普遍？二维数组中。

指针数组不用多介绍了，就是个普通数组，里面装的全是指针而已。

## 常量指针 & 指针常量
我们在介绍数组名是指针的时候用到了一个指针类型，叫做“指针常量”，也就是 `int * const var_name = &var[0];` 中的指针，这种指针内部的地址不能变动，只能在声明的时候定义一次，也就是不能指向别的变量了。**指针本身是一个常量**就称作**指针常量**我们称，数组名就是一种指针常量。字符串，也是一种指针常量。

还有一种指针，它本身不是常量，但它指向的是常量，大家想一想，这个指针的声明该怎么写？

```c
int c=10;
int const *ptr=&c;
```

或者：

```c
int c=10;
const int *ptr=&c;
```

是一样的。但是要清楚一点，这个常量的定义，是指不能通过 ptr 这个指针来修改 c 中的值了（`*ptr=20;` 会提示错误），但是 c 本身不是常量，用其他的指针或者，直接通过 `c=20;` 都是可以修改 c 的值的。这种**指向常量的指针**就叫做**常量指针**。

**指针常量/常量指针** 这两种是不是特别容易搞混啊？考试就考这个了！其实按照我们的结合律来判断也非常好判断，如果指针名先跟 const 结合了，这个指针内的地址就不能变了，那就是指针常量，而如果指针名先跟 \* 结合了，这就说明指针是可变的，然后遇到了 const 和某种类型，那就说明指针指向了某种常量，是常量指针。

来一个难一点的判断：

```c
int * const * (*test)();
```

首先从名字入手，`(*test)` 说明 test 是一个指针，然后向外，() 优先级较高，先判断后面的小括号，说名 test 指针指向一个没有参数的函数，其返回值目前未知，然后向前判断，首先遇到了一个 \*，说明返回值也是一个指针，指向了前面的 `(int * const)` ，接着跟 const 结合，返回指针为指针常量，接着是 `(int *)` 说明这个指针常量是一个二级指针，它指向了一个指向 int 型的指针。

也就是说 `test` 是一个指针，指向了一个函数，函数不接受参数，并且返回一个二级指针，这个二级指针是个指针常量，解除引用一次后的指针，指向一个 int 型变量。

当然 “常量指针常量” 这种变态也是存在的，这种指针不能修改地址，其对应的变量也不能通过此指针改变。

```c
int const * const ptr=(int *)10;
```

如果你之前写过程序，或者看我上文的函数指针例子中，发现很多字符串处理函数的字符串参数都是 `const char *` 这种类型，你就应该明白了，字符串譬如 `"Hello world"` 本质其实就是一个常量指针，`const char *` 的存在是为了保证内部的字符不会因为这个指针而发生改变。注意，如果你用一个字符串给指针赋值的话，这个指针是不能修改字符串的内容的，否则会报错哦。

所以常量指针的存在意义其实是为了保护数据，在操作的过程中不会因为一些错误修改而改变了内存中对应的数据的值。其意义还是十分重大的！

到此为止，如果你全部掌握了以上的内容，恭喜，你已经熟练掌握指针的操作了！

最后留一个问题，如果本文最后的 test 指针，我想让他的返回值是一个二级指针，但这个二级指针的解引用一次之后才是一个常量指针该怎么改写这个声明呢？非常简单啊哈哈！

[1]: /img/2017-12-7-C-pointer/ap&pa.png
